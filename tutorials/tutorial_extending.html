
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Extending FCM &#8212; cuda_hybrid  documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data Visualization" href="data_visualization.html" />
    <link rel="prev" title="Customizing Node Values" href="tutorial_obesity.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">cuda_hybrid  documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Contents
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../installation.html">
   Installation
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="index.html">
   Tutorials
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_serial.html">
     Serial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_parallel.html">
     Parallel
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tutorial_obesity.html">
     Customizing Node Values
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Extending FCM
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="data_visualization.html">
     Data Visualization
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../docs.html">
   Documentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../contribution.html">
   Contribution
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/tutorials/tutorial_extending.rst.txt"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.rst</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#running-the-simulation-with-communities">
   Running the simulation with communities
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Extending FCM</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#running-the-simulation-with-communities">
   Running the simulation with communities
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="extending-fcm">
<h1>Extending FCM<a class="headerlink" href="#extending-fcm" title="Permalink to this headline">#</a></h1>
<p>FCM models can be extended in different ways to overcome its shortcomings, one of which is <strong>Interval-Valued Fuzzy Cognitive Maps (IVFCMs)</strong> proposed by Hajek and Prochazka <a class="footnote-reference brackets" href="#f1" id="id1">1</a>. This tutorial introduces an example of modifying the library to fit the FCM model used. This will be done by extending upon the previous <a class="reference internal" href="tutorial_serial.html#serial"><span class="std std-ref">insurgency model</span></a>.</p>
<p>Since the node values and the edge weights for the IVFCMS are defined as intervals, the initial values and edge weights
will be initiated as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="k">def</span> <span class="nf">create_insurgency_fcm</span><span class="p">():</span>

    <span class="c1"># there are two data about each edge, lower and upper bounds</span>
    <span class="n">FCM</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_edgelist</span><span class="p">(</span><span class="s1">&#39;insurgency_simple.txt&#39;</span><span class="p">,</span> <span class="n">nodetype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                            <span class="n">data</span><span class="o">=</span><span class="p">([(</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]),</span> <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">())</span>

    <span class="c1"># Each node interval will use an initial random value which then be used to create an interval</span>
    <span class="c1"># and the results will be bounded between [0,1]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
    <span class="n">FCM</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;EconomicDevelopment&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">-</span> <span class="mf">0.02</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">val</span> <span class="o">+</span> <span class="mf">0.02</span><span class="p">)]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
    <span class="n">FCM</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;Rebelliousness&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">-</span> <span class="mf">0.03</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">val</span> <span class="o">+</span> <span class="mf">0.03</span><span class="p">)]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
    <span class="n">FCM</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;AbilityOfInsurgentsToControlThePopulation&quot;</span><span class="p">][</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">val</span> <span class="o">-</span> <span class="mf">0.04</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">val</span> <span class="o">+</span> <span class="mf">0.04</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">FCM</span>

<span class="c1"># Create the ABM/FCM hybrid model using the n</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">newman_watts_strogatz_graph</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="s2">&quot;FCM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_insurgency_fcm</span><span class="p">()</span>
<span class="n">hm</span> <span class="o">=</span> <span class="n">HybridModel</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>For this model, node values are randomly generated but for others, there might be certain rules for setting the values. Such situations can still use</p>
<p>Since the node values are now intervals, there are a few changes that need to be made to the library. In the original <a class="reference internal" href="../docs.html#cuda_hybrid.HybridModel" title="cuda_hybrid.HybridModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">HybridModel</span></code></a>, there are three 2D numpy arrays <code class="xref py py-attr docutils literal notranslate"><span class="pre">node_val</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">node_future_val</span></code>, and <code class="xref py py-attr docutils literal notranslate"><span class="pre">FCM_adj</span></code>, which will need to be changed to a 3D array to accommodate the intervals. In <a class="reference internal" href="../docs.html#cuda_hybrid.HybridModel.transformNetwork" title="cuda_hybrid.HybridModel.transformNetwork"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transformNetwork</span></code></a> method, replace:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">FCM_adj</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;FCM&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</pre></div>
</div>
<p>with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the size of the FCM adjecency matrix, which will be a 3D array, with the last dimension set as 2</span>
<span class="c1"># for lower and upper bounds</span>
<span class="n">fcm_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;FCM&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
<span class="bp">self</span><span class="o">.</span><span class="n">FCM_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">fcm_edges</span><span class="p">,</span> <span class="n">fcm_edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Get the edge list from the graph and populate the adjacency matrix. If there is no edge between</span>
<span class="c1"># two nodes, the interval will be [0. 0.]</span>
<span class="n">edge_lst</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;FCM&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_lst</span><span class="p">:</span>
    <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fcm_labels</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fcm_labels</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">FCM_adj</span><span class="p">[</span><span class="n">fr</span><span class="p">][</span><span class="n">to</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">FCM_adj</span><span class="p">[</span><span class="n">fr</span><span class="p">][</span><span class="n">to</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="s2">&quot;upper&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># store the node values and future node values that will serve as a buffer</span>
<span class="n">fcm_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;FCM&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
<span class="n">abm_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
<span class="bp">self</span><span class="o">.</span><span class="n">node_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">abm_edges</span><span class="p">,</span> <span class="n">fcm_edges</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">node_future_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">abm_edges</span><span class="p">,</span> <span class="n">fcm_edges</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># create a nested loop of the FCM node attribute and the value</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;FCM&quot;</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">fcm_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;val&quot;</span><span class="p">)):</span>
        <span class="c1"># store this value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_val</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcm_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_future_val</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcm_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># store the node values and future node values that will serve as a buffer</span>
<span class="n">fcm_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;FCM&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
<span class="n">abm_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
<span class="c1"># Added a third dimensions of 2 for the intervals</span>
<span class="bp">self</span><span class="o">.</span><span class="n">node_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">abm_edges</span><span class="p">,</span> <span class="n">fcm_edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">node_future_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">abm_edges</span><span class="p">,</span> <span class="n">fcm_edges</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># create a nested loop of the FCM node attribute and the value</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;FCM&quot;</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">fcm_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;val&quot;</span><span class="p">)):</span>
        <span class="c1"># store this value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_val</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcm_node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_val</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcm_node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_future_val</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcm_node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_future_val</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcm_node</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Another place that needs to be changed is the <code class="xref py py-func docutils literal notranslate"><span class="pre">runFCMCUDA</span></code> (or <code class="xref py py-func docutils literal notranslate"><span class="pre">runFCMCUDA_comm</span></code> if run with communities or <a class="reference internal" href="../docs.html#cuda_hybrid.HybridModel.runFCM" title="cuda_hybrid.HybridModel.runFCM"><code class="xref py py-meth docutils literal notranslate"><span class="pre">runFCM</span></code></a> if run serially). The rules for adding and multiplying intervals can be found in the paper <a class="footnote-reference brackets" href="#f1" id="id2">1</a>. Since the total input to a node will now have an interval, the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># loop through the concept nodes in the FCM</span>
<span class="k">for</span> <span class="n">concept</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">FCM_adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">weightSum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># loop through the edge values</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">FCM_adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">weightSum</span> <span class="o">+=</span> <span class="n">FCM_adj</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="n">concept</span><span class="p">]</span> <span class="o">*</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span>

    <span class="c1"># Apply tanh if out of range and buffer the new value</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">concept</span><span class="p">]</span> <span class="o">+</span> <span class="n">weightSum</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">node_future_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">concept</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>

<span class="c1"># check if all focus concepts are stable</span>
<span class="n">all_stable</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">focus</span><span class="p">)):</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">node_future_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">focus</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">focus</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">all_stable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">break</span>
<span class="c1">#break if all stable</span>
<span class="k">if</span> <span class="n">all_stable</span><span class="p">:</span>
    <span class="k">break</span>
</pre></div>
</div>
<p>can be changed to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># loop through the concept nodes in the FCM</span>
<span class="k">for</span> <span class="n">concept</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">FCM_adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="c1"># Replace weightSum with net_lower and net_upper since lists can not be create on GPU</span>
    <span class="n">net_lower</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">net_upper</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Save the current lower and upper bounds of the node to reference later</span>
    <span class="n">node_lower</span> <span class="o">=</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">concept</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">node_upper</span> <span class="o">=</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">concept</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># loop through the edge values</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">FCM_adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># multiply inter node value intervals with the edge weight interval</span>
        <span class="c1"># using the multiplication rule</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">FCM_adj</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="n">concept</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">edge</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">FCM_adj</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="n">concept</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">edge</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">FCM_adj</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="n">concept</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">edge</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># add the current input to the node to the net input using the</span>
        <span class="c1"># addition rule</span>
        <span class="n">net_lower</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lower</span> <span class="o">+</span> <span class="n">net_upper</span><span class="p">,</span>
                            <span class="n">upper</span> <span class="o">+</span> <span class="n">net_lower</span><span class="p">)</span>
        <span class="n">net_upper</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">+</span> <span class="n">net_upper</span>

    <span class="c1"># Calculate the new values using the addition rule and and apply sigmoid function</span>
    <span class="c1"># to both bounds</span>
    <span class="n">node_lower</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">node_lower</span> <span class="o">+</span> <span class="n">net_upper</span><span class="p">,</span>
                        <span class="n">node_upper</span> <span class="o">+</span> <span class="n">net_lower</span><span class="p">)</span>
    <span class="n">node_future_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">concept</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">node_lower</span><span class="p">))</span>
    <span class="n">node_upper</span> <span class="o">=</span> <span class="n">node_upper</span> <span class="o">+</span> <span class="n">net_upper</span>
    <span class="n">node_future_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">concept</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">node_lower</span><span class="p">))</span>

    <span class="c1"># the threshold check was not mentioned in the paper so that part was removed, though the parameter threshold is still kept for minimal changes</span>
</pre></div>
</div>
<section id="running-the-simulation-with-communities">
<h2>Running the simulation with communities<a class="headerlink" href="#running-the-simulation-with-communities" title="Permalink to this headline">#</a></h2>
<p>The last thing that is needed for this to work is the interaction function. In order to simplify the interaction function and introduce running with communities to accommodate more agents, the interaction function will be run in serial while the FCMs will be run in parallel. There are only a few differences between this interaction function and the interaction function in the <a class="reference internal" href="tutorial_serial.html#serial"><span class="std std-ref">serial insurgency model</span></a> because of broadcasting in numpy and will be noted with comments.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">econ_influence</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">influencing</span><span class="p">):</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">impact</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">influencing</span><span class="p">:</span>
        <span class="n">avg</span> <span class="o">+=</span> <span class="n">num</span>
    <span class="n">lowerThresh</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">threshold</span> <span class="o">/</span> <span class="mf">100.0</span>
    <span class="n">upperThresh</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">threshold</span> <span class="o">/</span> <span class="mf">100.0</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">val</span>
    <span class="c1"># avg &gt; val * upperThresh will result in a boolean array that compare every value along the axis</span>
    <span class="c1"># so using np.all will check if all values in the avg array pass the threshold</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">avg</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="o">*</span> <span class="n">upperThresh</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">impact</span> <span class="o">/</span> <span class="mf">100.0</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">avg</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="o">*</span> <span class="n">lowerThresh</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">-=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">impact</span> <span class="o">/</span> <span class="mf">100.0</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">insurgency_influence</span><span class="p">(</span><span class="n">influencedVal</span><span class="p">,</span> <span class="n">influencing</span><span class="p">):</span>
    <span class="c1"># nothing needs to be changed in this function</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">influencedVal</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">influencing</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">-=</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># nothing needs to be changed in this function</span>
<span class="k">def</span> <span class="nf">insurgency_interact</span><span class="p">(</span><span class="n">hm</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">hm</span><span class="o">.</span><span class="n">ABM_adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># loop through each agent</span>
    <span class="k">for</span> <span class="n">agent</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hm</span><span class="o">.</span><span class="n">ABM_adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># grab the neighbors</span>
        <span class="n">friends</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">agent</span><span class="p">)</span>
        <span class="c1"># get the numeric index for EconomicDevelopment and AbilityOfInsurgentsToControlThePopulation</span>
        <span class="n">econIdx</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">fcm_labels</span><span class="p">[</span><span class="s2">&quot;EconomicDevelopment&quot;</span><span class="p">]</span>
        <span class="n">insurgeIdx</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">fcm_labels</span><span class="p">[</span><span class="s2">&quot;AbilityOfInsurgentsToControlThePopulation&quot;</span><span class="p">]</span>
        <span class="n">econList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">insurgeList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># get the list of values for all the neighbors for the two concepts</span>
        <span class="k">for</span> <span class="n">friend</span> <span class="ow">in</span> <span class="n">friends</span><span class="p">:</span>
            <span class="n">econList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hm</span><span class="o">.</span><span class="n">node_val</span><span class="p">[</span><span class="n">friend</span><span class="p">][</span><span class="n">econIdx</span><span class="p">])</span>
            <span class="n">insurgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hm</span><span class="o">.</span><span class="n">node_val</span><span class="p">[</span><span class="n">friend</span><span class="p">][</span><span class="n">insurgeIdx</span><span class="p">])</span>
        <span class="c1"># agents now influence each other</span>
        <span class="n">hm</span><span class="o">.</span><span class="n">node_future_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">econIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">econ_influence</span><span class="p">(</span>
                <span class="n">hm</span><span class="o">.</span><span class="n">node_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">econIdx</span><span class="p">],</span>
                <span class="n">econList</span>
        <span class="p">)</span>
        <span class="n">hm</span><span class="o">.</span><span class="n">node_future_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">econIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">insurgency_influence</span><span class="p">(</span>
                <span class="n">hm</span><span class="o">.</span><span class="n">node_future_val</span><span class="p">[</span><span class="n">agent</span><span class="p">][</span><span class="n">econIdx</span><span class="p">],</span>
                <span class="n">insurgeList</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>The simulation then can be run using the <a class="reference internal" href="../docs.html#cuda_hybrid.HybridModel.run_parallel" title="cuda_hybrid.HybridModel.run_parallel"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_parallel</span></code></a> and setting <code class="docutils literal notranslate"><span class="pre">with_community</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code> along with providing a community algorithm.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hm</span><span class="o">.</span><span class="n">run_parallel</span><span class="p">([</span><span class="s2">&quot;Rebelliousness&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">],</span> <span class="mi">10</span><span class="p">,</span> <span class="n">insurgency_interact</span><span class="p">,</span> <span class="p">[</span><span class="n">hm</span><span class="p">],</span> <span class="mi">20</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">community</span><span class="o">.</span><span class="n">greedy_modularity_communities</span><span class="p">)</span>
</pre></div>
</div>
<p>The results are displayed below:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">{&#39;Rebelliousness&#39;: array([0.40053773, 0.5359976 ], dtype=float32)}</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="f1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span></dt>
<dd><p>Hajek, P., &amp; Prochazka, O. (2016, July). Interval-valued fuzzy cognitive maps for supporting business decisions. In 2016 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE) (pp. 531-536). IEEE.</p>
</dd>
</dl>
</section>
</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="tutorial_obesity.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Customizing Node Values</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="data_visualization.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Data Visualization</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Kareem Ghumrawi<br/>
  
      &copy; Copyright 2022, Kareem Ghumrawi, Philippe J. Giabbanelli.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>